
Directories present:
1)src : contains the source files that have been modified:

--ExternalSort.java
--PlanBuilder.java

2)attica.properties
--Please edit the paths with respect to your own working directory

3)classes:
this directory contains attica.jar  which is a compiled version of the entire source tree 

4)READ_Me_descriptionfile : Provides a detailed outline on the procedure used to implement External sort and discusses the improvements made to this code to reduce the number of disk IOS.




Overview of the algorithm used to implement External Sort:

To implement External Sort, I have augmented the ExternalSort.java file with the following instance variable :

/** rhe variable below keeps track of number of pages passed by the input operator **/
    private int numOfPages;

To implement External Sort, the following two methods have been added:

Method:
LinkedList<RelationIOManager> generateIniRuns(RelationIOManager Man,Relation Rel)
--this method reads the input file in batches of B pages, sorts them in main memory and generates the initial runs



Outline of the method:
1)Initialise a LinkedList of RelationsIOManagers and  call it 'runs_1' and assign a local counter(the scope of this counter is with in the method) 
2)Retrieve the page iterator from the input RelationIOMaanager Man and  if the returnList(a resuable list of tuples) is non-empty then clear the contents of the list before proceding to the next step
3) While the iterator has pages:
	get the next page of the iterator
	add the tuples of this page to returnList
	increment counter and numOfPages;
	if (counter==buffersize || the current page is the last page of the page iterator of Man)
		sort returnList
		create a new RelationIOManager  and add the tuples in returnList to this manager
		Add this new RelationIOManager to runs_1
		empty returnList and set counter to 0
4) Return runs_1
-- the linked list that will be outputted will contain ceil(x/B) RelationalIOManagers.

Method 2:
 RelationIOManager perform_externalSort(LinkedList<RelationIOManager> runs_1,int numOfPasses, Relation rel) 
--Until all X/B  temporary files are exhausted, this method iteratively reads B-1 temporary files at a time,  merges them and writes the output to disk. This procedure is repeated until there exists only one big sorted output file


Outline of the method:
The input of this method are:
 /*number of remaining passes*/
numOfPasses: (int)Math.ceil(Math.log(runs_1.size() )/Math.log(buffers-1));
/*The intial runs generated by the method discussed earlier*/
runs_1 
/* the relation of the operator*/
rel


Outline of the method:
Initialise  LinkedList of RelationIOManager: intermediateList --this stores the intermediate output files that have generated at the current pass. 

For i=1 to NumOfPasses (--this is loop 1 <-this iterates at each pass):
		Initialise a local counter 'c' --this counter keeps track of how many temporary files have been exhausted at each pass.
		assign a LinkedList of RelationIOManagers to intermediateList
		while c< runs_1.size()(--this is loop2 ):
			initialise the variable 'arraySize' to B-1  if (runs_1.size()-c) >B else set arraySize to runs_1.size()-c
			Create the following 5 arrays using the variable 'arraySize' to define their size:
				Array1 <- Array of RelationIOManagers 
				--At each iteration of this while loop, array1 is filled the RelationIOManagers occupying from the cth to c+arraySize index of runs_1
				Array2<- Array of Page Iterators
				- the ith index  represents the ith page iterator of the ith RelationIOManager in Array 1
				Array3<- Array of Pages
				-- the ith index  represents the ith page  of the ith Page iterator in Array 2
				Array4<- Array of Tuple Iterators
				--- the ith index  represents the ith Tuple Iterator  of the ith Page in Array 3
				Array5<-Array Of Tuples
				---- the ith index  represents the ith tuple  of the ith Tuple iterator in Array 4
			--This construction ensures that at maximum only B-1 pages are loaded into the buffer pool during the entire execution of a pass. Having the size of these arrays adapt diring each iteration of loop2 provides the following adavantage:  If the remaining number of temporary  files say ' N' waiting to be sorted is less than B-1,then the size of the arrays is set to 'N' hence allowing  the buffer pool manager to use the unused pages for other tasks.
				Initialise a new RelationalIOManager. Lets name it 'man'
				Initialise a counter 'pagesEmpty' to 0 and  initialize a tuple 'tuple_W ' and set it to null
				while pagesEmpty<arraySize(--this is loop3):
					set tuple_W to Array5[0]
					for (k=2:arraySize)(--this is loop4):
						if Array5[k]==null:
							Check if Array4[k] has any more tuples. If there exits more tuples than Array5[k]=Array4[k].next(). If the check fails, then check if Array2[k] has any more pages. If this check succeeds then set Array3[k]=Array2[k].next, set Array4[k]=Array3[k].iterator() and set Array5[k]=Array4[k].next(). But if this check fails then increment pagesEmpty by 1.
						if Array5[k]< tuple_W then set tuple_W to Array5[k]
					--- I have defined a method compareTuple(tuple T,tuple T1) that is used in the above line to implement an ordering of the tuples
					--After the for loop has been exited
					insert tuple_W into man and remove the tuple tuple_W from array5
				--After the while loop(loop3) has been exited, insert man to intermediateList
		--After (loop2) has been exited set runs_1 to intermediate list and move to the next pass
	--Once loop 1 has been exited: Check if the size of intermediateList is 1. If so output the RelationIOManager occupying the list. This corresponds to one giant sorted output file.
---Note : In the above pseudocode, I have opted to leave some other checks that I have added in my actual code to handle different types of exceptions and errors. 


Improvements added:
One of the inputs to the second method is 'runs_1' which contains temporary sorted output files. At each pass, runs_1 is reassigned to hold smaller number of sorted output files but which are bigger in size. Hence during execution of loop2, if a situation arises where the arraySize is 1, I have added an 'if clause'  that adds the single RelationalIOManager to the itermediateList directly without going through the later steps. This reduces the computational time of the algorithm.



--To reduce the number of disk IOS further, the second method is only triggered when the size of 'runs_1' is greater than 1. 
		



					

	






